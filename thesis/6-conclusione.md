# Conclusioni

ChemFuseKit permette di semplificare l'analisi chemiometrica, riducendo significativamente il carico di lavoro di configurazione da parte dell'utente. Proponendo un'interfaccia modulare e altamente schematica, la libreria elimina la necessità di gestire manualmente l'importazione e la gestione delle librerie su cui è basata. L'integrazione con le librerie per la creazione dei grafici permette di visualizzare facilmente sia i dati importati che i risultati delle analisi. Tramite il supporto per Jupyter Notebook, e di conseguenza per Google Colab, ChemFuseKit è utilizzabile da qualunque dispositivo, senza bisogno di installazione, con la possibilità di usufruire della potenza di calcolo di una piattaforma cloud. La semplicità della libreria, unita alla velocità con cui è possibile costruire *pipeline* di addestramento e analisi, permettono sveltezza nella ricerca e nella prototipazione. L'uniformità e la schematizzazione di struttura, classi e processi permettono un'elevata interoperabilità tra le diverse metodologie di analisi implementate. Infine, la struttura modulare del progetto come libreria espandibile e integrabile, unita ai sistemi CI/CD, permettono una rapida risposta ai *bug* e un'agevole aggiunta di nuove funzionalità.

La decisione di sviluppare una libreria invece che un'applicazione con interfaccia grafica rende, a prima vista, più complesso l'utilizzo. La curva di apprendimento più ripida, però, è compensata da una maggiore rapidità di utilizzo, ad apprendimento completato. Utenti esperti potrebbero comunque preferire l'utilizzo diretto delle librerie su cui ChemFuseKit si appoggia, per avere una maggiore flessibilità e un maggiore controllo sui parametri di analisi, senza introdurre astrazioni intermedie. A questo problema la libreria cerca di sopperire con la propria modularità, permettendo agli utenti di accedere ai dati semiprocessati, tra una fase e l'altra dell'analisi. Questo permette approcci ibridi che integrino altri software o altre librerie.

Tenendo conto di queste considerazioni, il target ideale di ChemFuseKit sono gli utenti intermedi, che desiderano una maggiore flessibilità rispetto a quella garantita da un software come Spectra, pur preferendo mantenere un'analisi più semplice rispetto a quella ottenibile con l'uso diretto di Scikit-learn. Oltre alle prospettive di uso diretto di questo progetto, bisogna considerare anche l'uso indiretto. Il sistema di predizione potrebbe essere utilizzato, ad esempio, all'interno di un modulo di analisi in tempo reale. L'intera libreria potrebbe essere impiegata come base per produrre un'applicazione desktop, o nel *back end* di una *web app* di analisi chemiometrica. *Fork* della libreria potrebbero essere adattati per analisi statistiche più generiche.

## Difficoltà incontrate

COMPLETARE

## Prospettive di sviluppo future

A ChemFuseKit potrebbero essere aggiunte con facilità nuove tecniche di analisi oltre alle già presenti. Ad esempio, potrebbe essere implementato un modulo per l’analisi QDA, presente nei notebook del dott. Felizzato, ma non inserita in ChemFuseKit per mancanza di tempo. Le altre prospettive riguardano il riutilizzo della libreria come base sulla quale costruire nuovi progetti, come spiegato nelle conclusioni. Nel progetto della terza versione della libreria era stata inserita l’idea di salvare i risultati delle analisi (tabelle, grafici e descrizioni dei progetti effettuati), come dizionari Python. Questa funzionalità non è stata implementata per mancanza di tempo. vrebbe permesso, tra le altre cose, di disaccoppiare l’elaborazione dei dati dalla loro visualizzazione. l dizionario risultante avrebbe potuto essere passato ad altri modulo, o ad applicazioni esterne, per permettere di presentare i dati in modi alternativi. Ad esempio, sarebbe stato possibile costruire un modulo per produrre un report in PDF delle analisi effettuate. Il dizionario sarebbe potuto risultare utile anche nello sviluppo di un’interfaccia grafica. Aggirando il sistema di visualizzazione interno alla libreria, esso sarebbe potuto essere stato passato all’interfaccia grafica per renderizzarlo all’interno di essa.


